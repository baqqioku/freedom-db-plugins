# freedom-db-plugins#### 介绍数据库插件基于SpringBoot2.X+myBatis3.5+以上  集成了 atomikos  解决多数据源的动态切换 同时可以满足对多数据源的事务管理，网上有很多类似的版本，但几乎只能满足静态注册的多数据源分布式事务，所以我才动手实现了这个版本，atomikos可插拔，提供了两个配置类,可以自主切换。注意，这里解决不了微服务的分布式事务（也就是单一实例对应单一数据库库），需要采用别的方案。1. DataSourceDynamicConfig  #集成了atomikos2. DataSourceNoXaDynamicConfig # 去除aomikos#### 插件配置.properties 数据源配置````# datasource 默认数据源druid.datasource.url=jdbc:mysql://localhost:3306/keta_custom?useUnicode=true&characterEncoding=UTF-8&useSSL=falsedruid.datasource.driverClassName=com.mysql.jdbc.Driverdruid.datasource.username=rootdruid.datasource.password=rootdruid.datasource.filters=statdruid.datasource.maxActive=20druid.datasource.initialSize=1druid.datasource.maxWait=60000druid.datasource.minIdle=1druid.datasource.timeBetweenEvictionRunsMillis=60000druid.datasource.minEvictableIdleTimeMillis=300000druid.datasource.validationQuery=SELECT 'x'druid.datasource.testWhileIdle=truedruid.datasource.testOnBorrow=falsedruid.datasource.testOnReturn=falsedruid.datasource.poolPreparedStatements=falsedruid.datasource.maxOpenPreparedStatements=20# 数据源1 依始类推，db2,db3custom.datasource.db1.name=db1custom.datasource.db1.url=jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&characterEncoding=UTF-8&useSSL=falsecustom.datasource.db1.driverClassName=com.mysql.jdbc.Drivercustom.datasource.db1.username=rootcustom.datasource.db1.password=rootcustom.datasource.db1.validationQuery=SELECT 1# 集成了atomikos 通过配置启动，如果不启用可以使用#不启动用是atomikosplatform.noXa.enabled=true#启用aomikosplatform.xa.enabled=true````#### 使用直接放入指定的pom文件``````         <groupId>com.guoguo.freedom</groupId>              <artifactId>freedom-db-plugins</artifactId>              <version>1.0-SNAPSHOT</version>              <scope>compile</scope>          </dependency>``````调用的时候如果是涉及到多数据源事务 使用spring注解即可 @Transactional``````   ###############    @Autowired    ServiceImplA serviceImplA;        @Autowired    ServiceImplB serviceImplB;        @Transactional    public  doTrancation(){        serviceImplA.serviceA();        serviceImplB.serviceB();        }    #################        //业务逻辑A  伪代码 ....    # ServiceImplA.serviceA()    @TargetDataSource(value = "db1")    serviceA(){      xxxx    }            //业务逻辑B  伪代码 ....    # ServiceImplB.serviceB()    @TargetDataSource(value = "db2")    serviceB(){      xxxx    }        ``````